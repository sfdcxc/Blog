# 《算法导论》学习笔记
@author: Darcy
2019/2/23 17:25:36 

## 第一部分 基础知识
## 第一章 算法在计算中的作用

### 算法
- 任何良定义的计算过程， 用于求解良说明的计算问题的工具，把输入转换成输出的过程
- 输入
	- 计算过程中取某个值或值的集合作为输入
- 输出
	- 计算过程中产生某个值或值的集合作为输出

### 对于排序算法效率依赖的因素
1. 被排序的项数
2. 这些项已被稍微排序的程度
3. 项值的可能限制
4. 计算机的体系结构
5. 将使用的存储设备的种类

### NP完全问题的性质
1. 对于NP完全问题，是否存在有效算法是未知的
2. 如果任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
3. NP完全问题有一些有着已知有效算法的问题

## 第二章 算法基础

### 插入排序
	输入：n个数的一个序列<a1,a2,...,an>
	输出: 输出序列的一个序列<a1',a2',...,an'>，满足a1'<=a2'<=...<=an'
	JAVA代码实现：
		public static void sort(int[] A){
	        for (int j = 1; j < A.length; j++){
	            int key = A[j];
	            //插入A[j] 进入排序好的序列中
	            int i = j - 1;
	            while (i >= 0 && A[i] > key){
	                A[i + 1] = A[i];
	                i = i - 1;
	            }
	            A[i+1] = key;
	        }
	    }

### 循环不变式与插入排序的正确性
- 循环不变式
	- 把A[1...j-1]构成的以排好的子数组称循环不变式
	- 性质
		1. 初始化：循环的第一次迭代之前，他为真
		2. 保持：如果循环的某次迭代之前他为真，那么下次迭代之前他依然为真
		3. 终止：在循环终止时，不变式为我们提供了一个有用的性质，该性质有助于证明算法是正确的。
- 对于插入排序
	- 初始化： 第一次循环迭代之前,A[1...j-1]仅由A[1]元素组成，该数组是排好序的。表明第一次循环之前循环不变式成立
	- 保持: 每次迭代保持循环不变式，4-7行，将A[j-1],A[j-2],等向右移动一个位置，直至找到A[j]的适当位置，插入，这时A[1..j]由原来在A[1...j]组成，但已排好序。
	- 终止: 终止条件j > A.length = n，每次循环迭代j增加1，必有j=n+1,终止条件，此时A[1...n]任由原来的A[1...n]组成，但已排好序。算法正确

### 分治法
1. 分解原问题为若干子问题，这些子问题是原问题的规模较小的实例
2. 解决这些子问题，递归地求解各子问题。若子问题规模足够小，则直接求解
3. 合并这些子问题的解成原问题的解

### 归并排序
1. 分解：分解待排序的n个元素的序列成各具有n/2个元素的两个子序列。
2. 解决：使用归并排序递归地排序两个子序列
3. 合并: 合并两个已排序的两个子序列

#
	JAVA代码实现:
	// 排序过程
	public static void MergeSort(int[] a, int p, int r){
        if(p < r){
            int q = (p + r) / 2;
            MergeSort(A, p, q);
            MergeSort(A, q + 1, r);
            Merge(A, p, q, r);
        }
    }

	// 归并过程
    public static void Merge(int []A, int p, int q, int r){
        int n1 = q - p + 1;
        int n2 = r - q;
        L = new int[n1 + 1];
        R = new int[n2 + 1];
        for(int i = 0; i < n1; i++){
            L[i] = A[p + i];
        }
        for(int i = 0; i < n2; i++){
            R[i] = A[q + i + 1];
        }
        L[n1] = Integer.MAX_VALUE;
        R[n2] = Integer.MAX_VALUE;
        int i = 0;
        int j = 0;
        for(int k = p; k <= r; k++){
            if (L[i] <= R[j] ){
                A[k] = L[i];
                i = i + 1;
            }else{
                A[k] = R[j];
                j = j + 1;
            }
        }
    }
		
		